## Лабораторная №3

*Подготовил - Кушнир Владислав, группа TI-164*

### 1.Шаблонный метод
![Template Method](https://refactoring.guru/images/patterns/content/template-method/template-method.png)

 **Шаблонный метод** — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.
 
 Паттерн Шаблонный метод предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом.

Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.

В данном случае был выполнен метод Template для создания каркаса домов. Есть в этом классе **final** метод, который нельзя переопределить из подклассов, а также содержит методы, которые будут выполняться в определенном порядке. Порядок означает, что вы не можете построить дом, начиная с окон или стен.

![](https://github.com/Dagonail/Lab3_TMPS/blob/master/Lab3_TMPS/Screens/template.PNG)

### 2.Стратегия

![Strategy](https://refactoring.guru/images/patterns/content/strategy/strategy.png)

**Стратегия** — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы, называемые стратегиями.

Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста, ссылаясь на одну из стратегий и делегируя ей выполнение работы. Чтобы сменить алгоритм, вам будет достаточно подставить в контекст другой объект-стратегию.

Важно, чтобы все стратегии имели общий интерфейс. Используя этот интерфейс, контекст будет независимым от конкретных классов стратегий. С другой стороны, вы сможете изменять и добавлять новые виды алгоритмов, не трогая код контекста.

Есть стратегии для создания некоторых типов зданий. Здания не имеют представления о том, как они будут создаваться, я просто вызвал стратегию строительства (инкапсулировал методы), я сохранил только ссылки на стратегии. Паттерн стратегия также следует порядку вызова методов из **BuildingContructionTemplateStrategy**.

![](https://github.com/Dagonail/Lab3_TMPS/blob/master/Lab3_TMPS/Screens/strategy_2.PNG)

![](https://github.com/Dagonail/Lab3_TMPS/blob/master/Lab3_TMPS/Screens/apply_strategy.PNG)

### 3.Посетитель
![Visitor](https://refactoring.guru/images/patterns/content/visitor/visitor.png)

**Посетитель** — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.
Паттерн Посетитель предлагает разместить новое поведение в отдельном классе, вместо того чтобы множить его сразу в нескольких классах. Объекты, с которыми должно было быть связано поведение, не будут выполнять его самостоятельно. Вместо этого вы будете передавать эти объекты в методы посетителя.

Код поведения, скорее всего, должен отличаться для объектов разных классов, поэтому и методов у посетителя должно быть несколько. Названия и принцип действия этих методов будет схож, но основное отличие будет в типе принимаемого в параметрах объекта.

В коде реализация шаблона посетителя аналогична **Template Method Pattern**, потому что были использованны методы для всех объектов, для тех, которые существуют, и для тех, которые будут созданы.Новый объект, который будет создан, будет знать, какую стратегию и методы применять для создания объекта.

Шаблон **Visitor** предполагает, что вы помещаете новое поведение в отдельный класс, называемый посетителем, вместо того, чтобы пытаться интегрировать его в существующие классы.


![](https://github.com/Dagonail/Lab3_TMPS/blob/master/Lab3_TMPS/Screens/visitor.PNG)

### 4.Итератор

![Iterator](https://refactoring.guru/images/patterns/content/iterator/iterator-comic-1.png)

**Итератор** — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.
Объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти. Одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом.

К тому же, если вам понадобится добавить новый способ обхода, вы сможете создать отдельный класс итератора, не изменяя существующий код коллекции.

Есть 2 интерфейса: **ConstructionsCollection**,**ConstructionIterator**,и один класс **ConstructionCollectionImpl**.

- **ConstructionsCollection-** содержит доступные методы для создания конструкций.
- **ConstructionIterator-** содержит один логический метод **hasNext()**, который проверяет, есть ли в списке следующий элемент, и метод **next()**, который отображает все объекты одного типа.

![](https://github.com/Dagonail/Lab3_TMPS/blob/master/Lab3_TMPS/Screens/hasNext_next.PNG)


### 5.Цепочка обязанностей

![Chain of Responsibility](https://refactoring.guru/images/patterns/content/chain-of-responsibility/chain-of-responsibility.png)

**Цепочка обязанностей** — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

Как и многие другие поведенческие паттерны, Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения в объекты. В нашем случае каждая проверка переедет в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.

А теперь по-настоящему важный этап. Паттерн предлагает связать объекты обработчиков в одну цепь. Каждый из них будет иметь ссылку на следующий обработчик в цепи. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.

Передавая запросы в первый обработчик цепочки, вы можете быть уверены, что все объекты в цепи смогут его обработать. При этом длина цепочки не имеет никакого значения.

И последний штрих. Обработчик не обязательно должен передавать запрос дальше, причём эта особенность может быть использована по-разному.

В данном случае пришлось выполнить некоторые действия для конструкций. Итак, есть порядок выполнения действий над объектом: **BuildChain**, **DecorateChain**, **SellChain** и один интерфейс, который содержит 2 метода для установки следующей цепочки и для выполнения действий,**setNextChain()**, **executeAction()**.

![](https://github.com/Dagonail/Lab3_TMPS/blob/master/Lab3_TMPS/Screens/chain_build.PNG)

![](https://github.com/Dagonail/Lab3_TMPS/blob/master/Lab3_TMPS/Screens/chain_decorate.PNG)

![](https://github.com/Dagonail/Lab3_TMPS/blob/master/Lab3_TMPS/Screens/chain_sell.PNG)
